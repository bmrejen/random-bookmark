{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./bookmarks.js","webpack:///./background.js","webpack:///../node_modules/chrome-promise/chrome-promise.js","webpack:///./blacklist.js","webpack:///../node_modules/chrome-promise/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","state","loaded","bookmarks","async","load","tree","storage","Promise","all","cp","getTree","local","visited","selected","Set","items","traverse","fn","parent","node","Array","isArray","children","url","has","id","add","push","title","pick","every","bookmark","unvisited","filter","picked","Math","floor","random","length","set","map","catch","console","error","chrome","webRequest","onBeforeRequest","addListener","details","method","type","blacklist","DISABLED","ADDRESS_BAR","cancel","urls","webNavigation","onBeforeNavigate","ALL","tabs","update","tabId","onCommitted","frameId","transitionQualifiers","includes","browserAction","onClicked","runtime","openOptionsPage","onCreated","onChanged","onMoved","onRemoved","changes","blacklistMode","onMessage","request","sender","reply","tab","root","factory","slice","ChromePromise","default","options","self","this","Error","setPromiseFunction","thisArg","args","arguments","resolve","reject","err","lastError","results","apply","fillProperties","source","target","val","permissions","onAdded","perms","approvedPerms","forEach","permission","api","exec","MODES","internals","blocked","String","split","trim","Boolean","RegExp","isBlocked","some","re","test","chromep"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,GAIjBlC,EAAoBA,EAAoBmC,EAAI,K,8DChFrD,MAAMC,EAAQ,CACZC,QAAQ,EACRC,UAAW,IAYNC,eAAeC,IACpB,MAAOC,EAAMC,SAAiBC,QAAQC,IAAI,CACxCC,IAAGP,UAAUQ,UACbD,IAAGH,QAAQK,MAAM9B,IAAI,CACnBqB,UAAW,GACXU,QAAS,OAIPC,EAAW,IAAIC,IAAIR,EAAQJ,WAC3BU,EAAU,IAAIE,IAAIR,EAAQM,SAE1BG,EAAQ,GAwBd,OA7CF,SAASC,EAASX,EAAMY,EAAIC,EAAS,MACnC,IAAK,MAAMC,KAAQd,EACjBY,EAAGE,EAAMD,GACLE,MAAMC,QAAQF,EAAKG,WACrBN,EAASG,EAAKG,SAAUL,EAAIE,GAkBhCH,CAASX,EAAM,CAACc,EAAMD,KACfC,EAAKI,MAILV,EAASW,IAAIL,EAAKM,KAAQZ,EAASW,IAAIN,GAAUA,EAAOO,OAK7DZ,EAASa,IAAIP,EAAKM,IAElBV,EAAMY,KAAK,CACTF,GAAIN,EAAKM,GACTG,MAAOT,EAAKS,MACZL,IAAKJ,EAAKI,IACVX,QAASA,EAAQY,IAAIL,EAAKM,SAI9BzB,EAAME,UAAYa,EAClBf,EAAMC,QAAS,EAERD,EAAME,UAGR,SAAS2B,IAKd,GAJK7B,EAAMC,QACTG,IAGEJ,EAAME,UAAU4B,MAAO9D,GAAMA,EAAE4C,SAEjC,IAAK,MAAMmB,KAAY/B,EAAME,UAC3B6B,EAASnB,SAAU,EAIvB,MAAMoB,EAAYhC,EAAME,UAAU+B,OAAQjE,IAAOA,EAAE4C,SAE7CsB,EAASF,EADDG,KAAKC,MAAMD,KAAKE,SAAWL,EAAUM,SAanD,OAVc,MAAVJ,IACFA,EAAOtB,SAAU,GAGnBH,IAAGH,QAAQK,MACR4B,IAAI,CACH3B,QAASZ,EAAME,UAAU+B,OAAQjE,GAAMA,EAAE4C,SAAS4B,IAAKxE,GAAMA,EAAEyD,MAEhEgB,MAAMC,QAAQC,OAEVT,E,WC5ETU,OAAOC,WAAWC,gBAAgBC,YAC/BC,IACC,GAAuB,QAAnBA,EAAQC,QAAqC,eAAjBD,EAAQE,MAClCC,QAAqBA,IAAgBC,UAAYD,IAAoBH,EAAQzB,KAAM,CACrF,GAAI4B,QAAqBA,IAAgBE,YAIvC,OAGF,MAAO,CAAEC,QAAQ,KAIvB,CAAEC,KAAM,CAAC,eACT,CAAC,aAGHX,OAAOY,cAAcC,iBAAiBV,YAAY5C,UAChD,GAAIgD,QAAqBA,IAAgBO,KAAOP,IAAoBH,EAAQzB,KAAM,CAChF,MAAMQ,EAAW7B,IACb6B,IAAaoB,IAAoBpB,EAASR,YACtCd,IAAGkD,KAAKC,OAAOZ,EAAQa,MAAO,CAClCtC,IAAKQ,EAASR,SAMtBqB,OAAOY,cAAcM,YAAYf,YAAaC,IAC5C,GAAwB,IAApBA,EAAQe,SAIRZ,QAAqBA,IAAgBE,aAIpCL,EAAQgB,qBAAqBC,SAAS,qBAIvCd,IAAoBH,EAAQzB,KAAM,CACpC,MAAMQ,EAAW7B,IACb6B,GACFtB,IAAGkD,KAAKC,OAAOZ,EAAQa,MAAO,CAC5BtC,IAAKQ,EAASR,SAMtBqB,OAAOsB,cAAcC,UAAUpB,YAAY5C,UACzCyC,OAAOwB,QAAQC,oBAIjBzB,OAAO1C,UAAUoE,UAAUvB,YAAY7C,GACvC0C,OAAO1C,UAAUqE,UAAUxB,YAAY7C,GACvC0C,OAAO1C,UAAUsE,QAAQzB,YAAY7C,GACrC0C,OAAO1C,UAAUuE,UAAU1B,YAAY7C,GAEvC0C,OAAOtC,QAAQiE,UAAUxB,YAAY5C,UAC/BuE,EAAQxE,iBACJA,KAGJwE,EAAQvB,WAAauB,EAAQC,sBACzBxB,QAIVA,MACAjD,IAEA0C,OAAOwB,QAAQQ,UAAU7B,YAAY5C,MAAO0E,EAASC,EAAQC,KAC3D,GAAqB,iBAAjBF,EAAQ3B,KAAyB,CACnC6B,IAEA,MAAMhD,EAAW7B,IACb6B,QACItB,IAAGkD,KAAKC,OAAOkB,EAAOE,IAAIvD,GAAI,CAClCF,IAAKQ,EAASR,YAIVd,IAAGkD,KAAKC,OAAOkB,EAAOE,IAAIvD,GAAI,CAAEF,IAAK,iD;;;;;;;;CCpFhD,SAAS0D,EAAMC,GAKZnH,EAAOD,QAekC,SAASmH,GACpD,aACA,IAAIE,EAAQ/D,MAAMxB,UAAUuF,MACxBtF,EAAiBnB,OAAOkB,UAAUC,eAKtC,OAFAuF,EAAcC,QAAUD,EAEjBA,EAIP,SAASA,EAAcE,GAErB,IAAI1C,GADJ0C,EAAUA,GAAW,IACA1C,QAAUqC,EAAKrC,OAChCrC,EAAU+E,EAAQ/E,SAAW0E,EAAK1E,QAClC6D,EAAUxB,EAAOwB,QACjBmB,EAAOC,KACX,IAAKD,EAAM,MAAM,IAAIE,MAAM,iDAU3B,SAASC,EAAmBzE,EAAI0E,GAE9B,OAAO,WACL,IAAIC,EAAOT,EAAMhH,KAAK0H,WAEtB,OAAO,IAAItF,GAAQ,SAASuF,EAASC,GACnCH,EAAKjE,MAIL,WACE,IAAIqE,EAAM5B,EAAQ6B,UACdC,EAAUf,EAAMhH,KAAK0H,WACzB,GAAIG,EACFD,EAAOC,QAEP,OAAQE,EAAQ5D,QACd,KAAK,EACHwD,IACA,MACF,KAAK,EACHA,EAAQI,EAAQ,IAChB,MACF,QACEJ,EAAQI,OAhBhBjF,EAAGkF,MAAMR,EAASC,OA0BxB,SAASQ,EAAeC,EAAQC,GAC9B,IAAK,IAAI/G,KAAO8G,EACd,GAAIxG,EAAe1B,KAAKkI,EAAQ9G,GAAM,CACpC,IAAIgH,EAMJ,IACEA,EAAMF,EAAO9G,GACb,MAAMyG,GACP,SAED,IAAI9C,SAAcqD,EAEL,WAATrD,GAAuBqD,aAAenB,EAIxCkB,EAAO/G,GADW,aAAT2D,EACKwC,EAAmBa,EAAKF,GAExBE,GALdD,EAAO/G,GAAO,GACd6G,EAAeG,EAAKD,EAAO/G,MA5DnC6G,EAAexD,EAAQ2C,GAEnB3C,EAAO4D,aACT5D,EAAO4D,YAAYC,QAAQ1D,aAmE7B,SAAkC2D,GAChC,GAAIA,EAAMF,aAAeE,EAAMF,YAAYlE,OAAQ,CACjD,IAAIqE,EAAgB,GACpBD,EAAMF,YAAYI,SAAQ,SAASC,GACjC,IAAIC,EAAM,SAASC,KAAKF,GACpBC,KAAOlE,IACT+D,EAAcG,GAAOlE,EAAOkE,OAGhCV,EAAeO,EAAepB,QAlHjBL,CAAQM,MAAQP,GALrC,CAoBkB,oBAATM,KAAuBA,KAAOC,O,+BC5BvC,4JAEO,MAAMwB,EAAQ,CACnBtD,IAAK,MACLN,SAAU,WACVC,YAAa,eAGT4D,EAAY,CAChBC,QAAS,GACT/H,KAAM6H,EAAM5D,UAGPjD,eAAeC,IACpB,MAAM,UAAE+C,EAAF,cAAawB,SAAwBlE,IAAGH,QAAQK,MAAM9B,IAAI,CAC9DsE,UAAW,GACXwB,cAAeqC,EAAM5D,WAsBvB,OAnBA6D,EAAU9H,KAAOwF,EAEbA,IAAkBqC,EAAM5D,SAC1B6D,EAAUC,QAAUC,OAAOhE,GACxBiE,MAAM,MACN5E,IAAKxE,GAAMA,EAAEqJ,QACbpF,OAAOqF,SACP9E,IAAKxE,IACJ,IACE,OAAO,IAAIuJ,OAAOvJ,GAClB,MAAO2E,GACP,OAAO,QAGVV,OAAOqF,SAEVL,EAAUC,QAAU,GAGfD,EAAUC,QAGZ,SAASM,EAAUjG,GACxB,OAAO0F,EAAUC,QAAQO,KAAMC,GAAOA,EAAGC,KAAKpG,IAGzC,SAASpC,IACd,OAAO8H,EAAU9H,O,kBC9CnB,IAEIyI,EAAU,IAFM,EAAQ,KAI5BA,EAAQvC,QAAUuC,EAElB7J,EAAOD,QAAU8J","file":"background.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 191);\n","import cp from 'chrome-promise';\n\nconst state = {\n  loaded: false,\n  bookmarks: [],\n};\n\nfunction traverse(tree, fn, parent = null) {\n  for (const node of tree) {\n    fn(node, parent);\n    if (Array.isArray(node.children)) {\n      traverse(node.children, fn, node);\n    }\n  }\n}\n\nexport async function load() {\n  const [tree, storage] = await Promise.all([\n    cp.bookmarks.getTree(),\n    cp.storage.local.get({\n      bookmarks: [],\n      visited: [],\n    }),\n  ]);\n\n  const selected = new Set(storage.bookmarks);\n  const visited = new Set(storage.visited);\n\n  const items = [];\n  traverse(tree, (node, parent) => {\n    if (!node.url) {\n      return;\n    }\n\n    if (!selected.has(node.id) && !selected.has(parent && parent.id)) {\n      return;\n    }\n\n    // If parent selected, but current node not\n    selected.add(node.id);\n\n    items.push({\n      id: node.id,\n      title: node.title,\n      url: node.url,\n      visited: visited.has(node.id),\n    });\n  });\n\n  state.bookmarks = items;\n  state.loaded = true;\n\n  return state.bookmarks;\n}\n\nexport function pick() {\n  if (!state.loaded) {\n    load();\n  }\n\n  if (state.bookmarks.every((i) => i.visited)) {\n    // All bookmarks visited at least once, reset visit history\n    for (const bookmark of state.bookmarks) {\n      bookmark.visited = false;\n    }\n  }\n\n  const unvisited = state.bookmarks.filter((i) => !i.visited);\n  const index = Math.floor(Math.random() * unvisited.length);\n  const picked = unvisited[index];\n\n  if (picked != null) {\n    picked.visited = true;\n  }\n\n  cp.storage.local\n    .set({\n      visited: state.bookmarks.filter((i) => i.visited).map((i) => i.id),\n    })\n    .catch(console.error);\n\n  return picked;\n}\n","import cp from 'chrome-promise';\n\nimport * as bookmarks from './bookmarks';\nimport * as blacklist from './blacklist';\n\nchrome.webRequest.onBeforeRequest.addListener(\n  (details) => {\n    if (details.method === 'GET' && details.type === 'main_frame') {\n      if (blacklist.mode() !== blacklist.MODES.DISABLED && blacklist.isBlocked(details.url)) {\n        if (blacklist.mode() === blacklist.MODES.ADDRESS_BAR) {\n          // We don't know navigation type at this point, since webNavigation.onCommitted can be\n          // fired after webRequest.onBeforeRequest, so we just ignore this request, redirection\n          // will happen in onCommitted if it's necessary\n          return;\n        }\n\n        return { cancel: true };\n      }\n    }\n  },\n  { urls: ['<all_urls>'] },\n  ['blocking'],\n);\n\nchrome.webNavigation.onBeforeNavigate.addListener(async (details) => {\n  if (blacklist.mode() === blacklist.MODES.ALL && blacklist.isBlocked(details.url)) {\n    const bookmark = bookmarks.pick();\n    if (bookmark && !blacklist.isBlocked(bookmark.url)) {\n      await cp.tabs.update(details.tabId, {\n        url: bookmark.url,\n      });\n    }\n  }\n});\n\nchrome.webNavigation.onCommitted.addListener((details) => {\n  if (details.frameId !== 0) {\n    return;\n  }\n\n  if (blacklist.mode() !== blacklist.MODES.ADDRESS_BAR) {\n    return;\n  }\n\n  if (!details.transitionQualifiers.includes('from_address_bar')) {\n    return;\n  }\n\n  if (blacklist.isBlocked(details.url)) {\n    const bookmark = bookmarks.pick();\n    if (bookmark) {\n      cp.tabs.update(details.tabId, {\n        url: bookmark.url,\n      });\n    }\n  }\n});\n\nchrome.browserAction.onClicked.addListener(async (tab) => {\n  chrome.runtime.openOptionsPage();\n});\n\n// Update list for all bookmarks changes\nchrome.bookmarks.onCreated.addListener(bookmarks.load);\nchrome.bookmarks.onChanged.addListener(bookmarks.load);\nchrome.bookmarks.onMoved.addListener(bookmarks.load);\nchrome.bookmarks.onRemoved.addListener(bookmarks.load);\n\nchrome.storage.onChanged.addListener(async (changes) => {\n  if (changes.bookmarks) {\n    await bookmarks.load();\n  }\n\n  if (changes.blacklist || changes.blacklistMode) {\n    await blacklist.load();\n  }\n});\n\nblacklist.load();\nbookmarks.load();\n\nchrome.runtime.onMessage.addListener(async (request, sender, reply) => {\n  if (request.type === 'loadBookmark') {\n    reply();\n\n    const bookmark = bookmarks.pick();\n    if (bookmark) {\n      await cp.tabs.update(sender.tab.id, {\n        url: bookmark.url,\n      });\n    } else {\n      // In case we don't have a bookmark to use, we redirect to default newtab page\n      await cp.tabs.update(sender.tab.id, { url: 'chrome-search://local-ntp/local-ntp.html' });\n    }\n  }\n});\n","/*!\n * chrome-promise\n * https://github.com/tfoxy/chrome-promise\n *\n * Copyright 2015 TomÃ¡s Fox\n * Released under the MIT license\n */\n\n(function(root, factory) {\n  if (typeof exports === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory(this || root);\n  } else if (typeof define === 'function' && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory.bind(null, this || root));\n  } else {\n    // Browser globals (root is window)\n    root.ChromePromise = factory(root);\n    var script = document.currentScript;\n    if (script) {\n      var name = script.dataset.instance;\n      if (name) {\n        root[name] = new root.ChromePromise();\n      }\n    }\n  }\n}(typeof self !== 'undefined' ? self : this, function(root) {\n  'use strict';\n  var slice = Array.prototype.slice,\n      hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  // Temporary hacky fix to make TypeScript `import` work\n  ChromePromise.default = ChromePromise;\n\n  return ChromePromise;\n\n  ////////////////\n\n  function ChromePromise(options) {\n    options = options || {};\n    var chrome = options.chrome || root.chrome;\n    var Promise = options.Promise || root.Promise;\n    var runtime = chrome.runtime;\n    var self = this;\n    if (!self) throw new Error('ChromePromise must be called with new keyword');\n\n    fillProperties(chrome, self);\n\n    if (chrome.permissions) {\n      chrome.permissions.onAdded.addListener(permissionsAddedListener);\n    }\n\n    ////////////////\n\n    function setPromiseFunction(fn, thisArg) {\n\n      return function() {\n        var args = slice.call(arguments);\n\n        return new Promise(function(resolve, reject) {\n          args.push(callback);\n\n          fn.apply(thisArg, args);\n\n          function callback() {\n            var err = runtime.lastError;\n            var results = slice.call(arguments);\n            if (err) {\n              reject(err);\n            } else {\n              switch (results.length) {\n                case 0:\n                  resolve();\n                  break;\n                case 1:\n                  resolve(results[0]);\n                  break;\n                default:\n                  resolve(results);\n              }\n            }\n          }\n        });\n\n      };\n\n    }\n\n    function fillProperties(source, target) {\n      for (var key in source) {\n        if (hasOwnProperty.call(source, key)) {\n          var val;\n          // Sometime around Chrome v71, certain deprecated methods on the\n          // extension APIs started using proxies to throw an error if the\n          // deprecated methods were accessed, regardless of whether they\n          // were invoked or not.  That would cause this code to throw, even\n          // if no one was actually invoking that method.\n          try {\n            val = source[key];\n          } catch(err) {\n           continue;\n          }\n          var type = typeof val;\n\n          if (type === 'object' && !(val instanceof ChromePromise)) {\n            target[key] = {};\n            fillProperties(val, target[key]);\n          } else if (type === 'function') {\n            target[key] = setPromiseFunction(val, source);\n          } else {\n            target[key] = val;\n          }\n        }\n      }\n    }\n\n    function permissionsAddedListener(perms) {\n      if (perms.permissions && perms.permissions.length) {\n        var approvedPerms = {};\n        perms.permissions.forEach(function(permission) {\n          var api = /^[^.]+/.exec(permission);\n          if (api in chrome) {\n            approvedPerms[api] = chrome[api];\n          }\n        });\n        fillProperties(approvedPerms, self);\n      }\n    }\n  }\n}));\n","import cp from 'chrome-promise';\n\nexport const MODES = {\n  ALL: 'all',\n  DISABLED: 'disabled',\n  ADDRESS_BAR: 'address-bar',\n};\n\nconst internals = {\n  blocked: [],\n  mode: MODES.DISABLED,\n};\n\nexport async function load() {\n  const { blacklist, blacklistMode } = await cp.storage.local.get({\n    blacklist: '',\n    blacklistMode: MODES.DISABLED,\n  });\n\n  internals.mode = blacklistMode;\n\n  if (blacklistMode !== MODES.DISABLED) {\n    internals.blocked = String(blacklist)\n      .split('\\n')\n      .map((i) => i.trim())\n      .filter(Boolean)\n      .map((i) => {\n        try {\n          return new RegExp(i);\n        } catch (error) {\n          return null;\n        }\n      })\n      .filter(Boolean);\n  } else {\n    internals.blocked = [];\n  }\n\n  return internals.blocked;\n}\n\nexport function isBlocked(url) {\n  return internals.blocked.some((re) => re.test(url));\n}\n\nexport function mode() {\n  return internals.mode;\n}\n","var ChromePromise = require('./chrome-promise');\n\nvar chromep = new ChromePromise();\n// Temporary hacky fix to make TypeScript `import` work\nchromep.default = chromep;\n\nmodule.exports = chromep;\n"],"sourceRoot":""}